<!DOCTYPE html>
<html>
	<head>
		<title>Geohackers</title>
		<script src="babylon.js"></script>
		<script src="testmaterial.js"></script>
		<style>
		html, body {
			overflow: hidden;
			width   : 100%;
			height  : 100%;
			margin  : 0;
			padding : 0;
		}

		#renderCanvas {
			width   : 100%;
			height  : 100%;
			touch-action: none;
		}
		</style>
	</head>
	<body>
	    <script type="application/vertexShader" id="vertexShaderCode2">
			precision highp float;

			// Attributes
			attribute vec3 position;
			attribute vec3 normal;
			attribute vec2 uv;

			// Uniforms
			uniform mat4 worldViewProjection;
			uniform float time;
			uniform mat4 lightMatrix0;

			// Varying
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec2 vUV;
			varying vec4 vPositionFromLight0;

			void main(void) {
			    vec3 v = position;
			   // v.x += 3.0 * sin(2.0 * position.y + (9. * time));

				// vPositionFromLight0 = lightMatrix0 * v;

			    gl_Position = worldViewProjection * vec4(v, 1.0);

			    vPosition = position;
			    vNormal = normal;
			    vUV = uv;
			}
	    </script>

	    <script type="application/fragmentShader" id="fragmentShaderCode2">
			precision highp float;

			// Varying
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec2 vUV;
			varying vec4 vPositionFromLight0;

			// Uniforms
			uniform mat4 world;

			// Refs
			uniform vec3 cameraPosition;
			uniform sampler2D textureSampler;
			uniform sampler2D shadowSampler0;
			uniform vec3 shadowsInfo0;

/*
			float computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness, float bias)
			{
				vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;
				depth = 0.5 * depth + vec3(0.5);
				vec2 uv = depth.xy;

				if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)
				{
					return 1.0;
				}

				float shadow = unpack(texture2D(shadowSampler, uv)) + bias;

				if (depth.z > shadow)
				{
					return darkness;
				}
				return 1.;
			}
*/

			void main(void) {
			    vec3 vLightPosition = vec3(0,20,10);
			    
			    // World values
			    vec3 vPositionW = vec3(world * vec4(vPosition, 1.0));
			    vec3 vNormalW = normalize(vec3(world * vec4(vNormal, 0.0)));
			    vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
			    
			    // Light
			    vec3 lightVectorW = normalize(vLightPosition - vPositionW);
			    vec3 color = texture2D(shadowSampler0, vUV).rgb;
//			    float shadow = computeShadow(vPositionFromLight0, shadowSampler0, shadowsInfo0.x, shadowsInfo0.z);
			

			    // diffuse
			    float ndl = max(0., dot(vNormalW, lightVectorW));
			    // ndl += shadow;
			    ndl = 1.0;
			    
			    // Specular
			    vec3 angleW = normalize(viewDirectionW + lightVectorW);
			    float specComp = max(0., dot(vNormalW, angleW));
			    specComp = pow(specComp, max(1., 64.)) * 2.;
			    
			    gl_FragColor = vec4(color * ndl + vec3(specComp), 1.);
			}
	    </script>
		<pre id="taag_output_text" style="float:left;" class="fig" contenteditable="true">
		   _____            _                _                 
		  / ____|          | |              | |                
		 | |  __  ___  ___ | |__   __ _  ___| | _____ _ __ ___ 
		 | | |_ |/ _ \/ _ \| '_ \ / _` |/ __| |/ / _ \ '__/ __|
		 | |__| |  __/ (_) | | | | (_| | (__|   &lt;  __/ |  \__ \
		  \_____|\___|\___/|_| |_|\__,_|\___|_|\_\___|_|  |___/
		</pre>
		<canvas id="renderCanvas"></canvas>
		<script src="app.js"></script>
	</body>
</html>